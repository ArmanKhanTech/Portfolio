var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { Matrix4, Mesh, BufferGeometry, MathUtils, DataTexture, RGBAFormat, FloatType, BufferAttribute } from "three";
const _identityMatrix = new Matrix4();
const _zeroMatrix = new Matrix4().set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
const batchingParsVertex = (
  /* glsl */
  `
#ifdef BATCHING
	attribute float id;
	uniform highp sampler2D batchingTexture;
	uniform int batchingTextureSize;
	mat4 getBatchingMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( batchingTextureSize ) );
		float y = floor( j / float( batchingTextureSize ) );
		float dx = 1.0 / float( batchingTextureSize );
		float dy = 1.0 / float( batchingTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( batchingTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( batchingTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( batchingTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( batchingTexture, vec2( dx * ( x + 3.5 ), y ) );
		return mat4( v1, v2, v3, v4 );
	}
#endif
`
);
const batchingbaseVertex = (
  /* glsl */
  `
#ifdef BATCHING
	mat4 batchingMatrix = getBatchingMatrix( id );
#endif
`
);
const batchingnormalVertex = (
  /* glsl */
  `
#ifdef BATCHING
	objectNormal = vec4( batchingMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( batchingMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif
`
);
const batchingVertex = (
  /* glsl */
  `
#ifdef BATCHING
	transformed = ( batchingMatrix * vec4( transformed, 1.0 ) ).xyz;
#endif
`
);
class BatchedMesh extends Mesh {
  constructor(maxGeometryCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material) {
    super(new BufferGeometry(), material);
    __publicField(this, "_vertexStarts");
    __publicField(this, "_vertexCounts");
    __publicField(this, "_indexStarts");
    __publicField(this, "_indexCounts");
    __publicField(this, "_visibles");
    __publicField(this, "_alives");
    __publicField(this, "_maxGeometryCount");
    __publicField(this, "_maxVertexCount");
    __publicField(this, "_maxIndexCount");
    __publicField(this, "_geometryInitialized");
    __publicField(this, "_geometryCount");
    __publicField(this, "_vertexCount");
    __publicField(this, "_indexCount");
    __publicField(this, "_matrices");
    __publicField(this, "_matricesArray");
    __publicField(this, "_matricesTexture");
    __publicField(this, "_matricesTextureSize");
    __publicField(this, "_customUniforms");
    this._vertexStarts = [];
    this._vertexCounts = [];
    this._indexStarts = [];
    this._indexCounts = [];
    this._visibles = [];
    this._alives = [];
    this._maxGeometryCount = maxGeometryCount;
    this._maxVertexCount = maxVertexCount;
    this._maxIndexCount = maxIndexCount;
    this._geometryInitialized = false;
    this._geometryCount = 0;
    this._vertexCount = 0;
    this._indexCount = 0;
    this._matrices = [];
    this._matricesArray = null;
    this._matricesTexture = null;
    this._matricesTextureSize = null;
    this.frustumCulled = false;
    this._customUniforms = {
      batchingTexture: { value: null },
      batchingTextureSize: { value: 0 }
    };
    this._initMatricesTexture();
    this._initShader();
  }
  _initMatricesTexture() {
    let size = Math.sqrt(this._maxGeometryCount * 4);
    size = MathUtils.ceilPowerOfTwo(size);
    size = Math.max(size, 4);
    const matricesArray = new Float32Array(size * size * 4);
    const matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType);
    this._matricesArray = matricesArray;
    this._matricesTexture = matricesTexture;
    this._matricesTextureSize = size;
    this._customUniforms.batchingTexture.value = this._matricesTexture;
    this._customUniforms.batchingTextureSize.value = this._matricesTextureSize;
  }
  _initShader() {
    const currentOnBeforeCompile = this.material.onBeforeCompile;
    const customUniforms = this._customUniforms;
    this.material.onBeforeCompile = function onBeforeCompile(parameters, renderer) {
      parameters.vertexShader = parameters.vertexShader.replace("#include <skinning_pars_vertex>", "#include <skinning_pars_vertex>\n" + batchingParsVertex).replace(
        "#include <skinnormal_vertex>",
        "#include <skinnormal_vertex>\n" + batchingbaseVertex + batchingnormalVertex
      ).replace("#include <skinning_vertex>", "#include <skinning_vertex>\n" + batchingVertex);
      for (const uniformName in customUniforms) {
        parameters.uniforms[uniformName] = customUniforms[uniformName];
      }
      currentOnBeforeCompile.call(this, parameters, renderer);
    };
    this.material.defines = this.material.defines || {};
    this.material.defines.BATCHING = false;
  }
  getGeometryCount() {
    return this._geometryCount;
  }
  getVertexCount() {
    return this._vertexCount;
  }
  getIndexCount() {
    return this._indexCount;
  }
  applyGeometry(geometry) {
    var _a;
    if (this._geometryCount >= this._maxGeometryCount)
      ;
    if (this._geometryInitialized === false) {
      for (const attributeName in geometry.attributes) {
        const srcAttribute = geometry.getAttribute(attributeName);
        const { array, itemSize, normalized } = srcAttribute;
        const dstArray = new array.constructor(this._maxVertexCount * itemSize);
        const dstAttribute = new srcAttribute.constructor(dstArray, itemSize, normalized);
        dstAttribute.setUsage(srcAttribute.usage);
        this.geometry.setAttribute(attributeName, dstAttribute);
      }
      if (geometry.getIndex() !== null) {
        const indexArray = this._maxVertexCount > 65536 ? new Uint32Array(this._maxIndexCount) : new Uint16Array(this._maxIndexCount);
        this.geometry.setIndex(new BufferAttribute(indexArray, 1));
      }
      const idArray = this._maxGeometryCount > 65536 ? new Uint32Array(this._maxVertexCount) : new Uint16Array(this._maxVertexCount);
      this.geometry.setAttribute("id", new BufferAttribute(idArray, 1));
      this._geometryInitialized = true;
    }
    const hasIndex = this.geometry.getIndex() !== null;
    const dstIndex = this.geometry.getIndex();
    const srcIndex = geometry.getIndex();
    const srcPositionAttribute = geometry.getAttribute("position");
    this._vertexStarts.push(this._vertexCount);
    this._vertexCounts.push(srcPositionAttribute.count);
    if (hasIndex) {
      this._indexStarts.push(this._indexCount);
      this._indexCounts.push(srcIndex.count);
    }
    this._visibles.push(true);
    this._alives.push(true);
    for (const attributeName in geometry.attributes) {
      const srcAttribute = geometry.getAttribute(attributeName);
      const dstAttribute = this.geometry.getAttribute(attributeName);
      dstAttribute.array.set(srcAttribute.array, this._vertexCount * dstAttribute.itemSize);
      dstAttribute.needsUpdate = true;
    }
    if (hasIndex) {
      for (let i = 0; i < srcIndex.count; i++) {
        dstIndex.setX(this._indexCount + i, this._vertexCount + srcIndex.getX(i));
      }
      this._indexCount += srcIndex.count;
      dstIndex.needsUpdate = true;
    }
    const geometryId = this._geometryCount;
    this._geometryCount++;
    const idAttribute = this.geometry.getAttribute("id");
    for (let i = 0; i < srcPositionAttribute.count; i++) {
      idAttribute.setX(this._vertexCount + i, geometryId);
    }
    idAttribute.needsUpdate = true;
    this._vertexCount += srcPositionAttribute.count;
    this._matrices.push(new Matrix4());
    _identityMatrix.toArray((_a = this._matricesArray) != null ? _a : void 0, geometryId * 16);
    this._matricesTexture.needsUpdate = true;
    return geometryId;
  }
  deleteGeometry(geometryId) {
    if (geometryId >= this._alives.length || this._alives[geometryId] === false) {
      return this;
    }
    this._alives[geometryId] = false;
    _zeroMatrix.toArray(this._matricesArray, geometryId * 16);
    this._matricesTexture.needsUpdate = true;
    return this;
  }
  optimize() {
    return this;
  }
  setMatrixAt(geometryId, matrix) {
    if (geometryId >= this._matrices.length || this._alives[geometryId] === false) {
      return this;
    }
    this._matrices[geometryId].copy(matrix);
    if (this._visibles[geometryId] === true) {
      matrix.toArray(this._matricesArray, geometryId * 16);
      this._matricesTexture.needsUpdate = true;
    }
    return this;
  }
  getMatrixAt(geometryId, matrix) {
    if (geometryId >= this._matrices.length || this._alives[geometryId] === false) {
      return matrix;
    }
    return matrix.copy(this._matrices[geometryId]);
  }
  setVisibleAt(geometryId, visible) {
    if (geometryId >= this._visibles.length || this._alives[geometryId] === false) {
      return this;
    }
    if (this._visibles[geometryId] === visible) {
      return this;
    }
    if (visible === true) {
      this._matrices[geometryId].toArray(this._matricesArray, geometryId * 16);
    } else {
      _zeroMatrix.toArray(this._matricesArray, geometryId * 16);
    }
    this._matricesTexture.needsUpdate = true;
    this._visibles[geometryId] = visible;
    return this;
  }
  getVisibleAt(geometryId) {
    if (geometryId >= this._visibles.length || this._alives[geometryId] === false) {
      return false;
    }
    return this._visibles[geometryId];
  }
  copy(source) {
    super.copy(source);
    return this;
  }
  toJSON(meta) {
    return super.toJSON(meta);
  }
  dispose() {
    var _a;
    this.geometry.dispose();
    (_a = this._matricesTexture) == null ? void 0 : _a.dispose();
    this._matricesTexture = null;
    return this;
  }
  // @ts-ignore
  onBeforeRender() {
    if (this.material.defines) {
      this.material.defines.BATCHING = true;
    }
  }
  // @ts-ignore
  onAfterRender() {
    if (this.material.defines) {
      this.material.defines.BATCHING = false;
    }
  }
}
export {
  BatchedMesh
};
//# sourceMappingURL=BatchedMesh.js.map

{"version":3,"file":"PoissionBlur.cjs","sources":["../../../src/effects/N8AO/PoissionBlur.js"],"sourcesContent":["import * as THREE from 'three'\n\nconst PoissionBlur = {\n  uniforms: {\n    sceneDiffuse: { value: null },\n    sceneDepth: { value: null },\n    tDiffuse: { value: null },\n    projMat: { value: new THREE.Matrix4() },\n    viewMat: { value: new THREE.Matrix4() },\n    projectionMatrixInv: { value: new THREE.Matrix4() },\n    viewMatrixInv: { value: new THREE.Matrix4() },\n    cameraPos: { value: new THREE.Vector3() },\n    resolution: { value: new THREE.Vector2() },\n    time: { value: 0.0 },\n    r: { value: 5.0 },\n    blueNoise: { value: null },\n    radius: { value: 12.0 },\n    worldRadius: { value: 5.0 },\n    index: { value: 0.0 },\n    poissonDisk: { value: [] },\n    distanceFalloff: { value: 1.0 },\n    near: { value: 0.1 },\n    far: { value: 1000.0 },\n    logDepth: { value: false },\n    screenSpaceRadius: { value: false },\n  },\n  depthWrite: false,\n  depthTest: false,\n\n  vertexShader: /* glsl */ `\n\t\tvarying vec2 vUv;\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = vec4(position, 1.0);\n\t\t}`,\n  fragmentShader: /* glsl */ `\n\t\tuniform sampler2D sceneDiffuse;\n    uniform highp sampler2D sceneDepth;\n    uniform sampler2D tDiffuse;\n    uniform sampler2D blueNoise;\n    uniform mat4 projectionMatrixInv;\n    uniform mat4 viewMatrixInv;\n    uniform vec2 resolution;\n    uniform float r;\n    uniform float radius;\n     uniform float worldRadius;\n    uniform float index;\n     uniform float near;\n     uniform float far;\n     uniform float distanceFalloff;\n     uniform bool logDepth;\n     uniform bool screenSpaceRadius;\n    varying vec2 vUv;\n\n    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)\n    {\n        highp float z_n = 2.0 * d - 1.0;\n        return 2.0 * zNear * zFar / (zFar + zNear - z_n * (zFar - zNear));\n    }\n    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {\n     float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;\n     float a = farZ / (farZ - nearZ);\n     float b = farZ * nearZ / (nearZ - farZ);\n     float linDepth = a + b / depth;\n     return linearize_depth(linDepth, nearZ, farZ);\n   }\n   highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {\n     return nearZ + (farZ - nearZ) * d;\n   }\n   vec3 getWorldPosLog(vec3 posS) {\n     vec2 uv = posS.xy;\n     float z = posS.z;\n     float nearZ =near;\n     float farZ = far;\n     float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;\n     float a = farZ / (farZ - nearZ);\n     float b = farZ * nearZ / (nearZ - farZ);\n     float linDepth = a + b / depth;\n     vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;\n     vec4 wpos = projectionMatrixInv * clipVec;\n     return wpos.xyz / wpos.w;\n   }\n    vec3 getWorldPos(float depth, vec2 coord) {\n     #ifdef LOGDEPTH\n          return getWorldPosLog(vec3(coord, depth));\n     #endif\n        \n        float z = depth * 2.0 - 1.0;\n        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\n        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;\n        // Perspective division\n       vec4 worldSpacePosition = viewSpacePosition;\n       worldSpacePosition.xyz /= worldSpacePosition.w;\n        return worldSpacePosition.xyz;\n    }\n    #include <common>\n    #define NUM_SAMPLES 16\n    uniform vec2 poissonDisk[NUM_SAMPLES];\n    void main() {\n        const float pi = 3.14159;\n        vec2 texelSize = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n        vec2 uv = vUv;\n        vec4 data = texture2D(tDiffuse, vUv);\n        float occlusion = data.a;\n        float baseOcc = data.a;\n        vec3 normal = data.rgb * 2.0 - 1.0;\n        float count = 1.0;\n        float d = texture2D(sceneDepth, vUv).x;\n        if (d == 1.0) {\n          gl_FragColor = data;\n          return;\n        }\n        vec3 worldPos = getWorldPos(d, vUv);\n        float size = radius;\n        float angle;\n        if (index == 0.0) {\n             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).x * PI2;\n        } else if (index == 1.0) {\n             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).y * PI2;\n        } else if (index == 2.0) {\n             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).z * PI2;\n        } else {\n             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).w * PI2;\n        }\n\n        mat2 rotationMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n        float radiusToUse = screenSpaceRadius ? distance(\n          worldPos,\n          getWorldPos(d, vUv +\n            vec2(worldRadius, 0.0) / resolution)\n        ) : worldRadius;\n        float distanceFalloffToUse =screenSpaceRadius ?\n            radiusToUse * distanceFalloff\n        : distanceFalloff;\n\n\n        for(int i = 0; i < NUM_SAMPLES; i++) {\n            vec2 offset = (rotationMatrix * poissonDisk[i]) * texelSize * size;\n            vec4 dataSample = texture2D(tDiffuse, uv + offset);\n            float occSample = dataSample.a;\n            vec3 normalSample = dataSample.rgb * 2.0 - 1.0;\n            float dSample = texture2D(sceneDepth, uv + offset).x;\n            vec3 worldPosSample = getWorldPos(dSample, uv + offset);\n            float tangentPlaneDist = abs(dot(worldPos - worldPosSample, normal));\n            float rangeCheck = dSample == 1.0 ? 0.0 :exp(-1.0 * tangentPlaneDist * (1.0 / distanceFalloffToUse)) * max(dot(normal, normalSample), 0.0) * (1.0 - abs(occSample - baseOcc));\n            occlusion += occSample * rangeCheck;\n            count += rangeCheck;\n        }\n        if (count > 0.0) {\n          occlusion /= count;\n        }\n        #ifdef LOGDEPTH\n          occlusion = clamp(occlusion, 0.0, 1.0);\n          if (occlusion == 0.0) {\n            occlusion = 1.0;\n          }\n        #endif\n        gl_FragColor = vec4(0.5 + 0.5 * normal, occlusion);\n    }\n    `,\n}\n\nexport { PoissionBlur }\n"],"names":["THREE"],"mappings":";;;;;;;;;;;;;;;;;;;;AAEK,MAAC,eAAe;AAAA,EACnB,UAAU;AAAA,IACR,cAAc,EAAE,OAAO,KAAM;AAAA,IAC7B,YAAY,EAAE,OAAO,KAAM;AAAA,IAC3B,UAAU,EAAE,OAAO,KAAM;AAAA,IACzB,SAAS,EAAE,OAAO,IAAIA,iBAAM,QAAO,EAAI;AAAA,IACvC,SAAS,EAAE,OAAO,IAAIA,iBAAM,QAAO,EAAI;AAAA,IACvC,qBAAqB,EAAE,OAAO,IAAIA,iBAAM,QAAO,EAAI;AAAA,IACnD,eAAe,EAAE,OAAO,IAAIA,iBAAM,QAAO,EAAI;AAAA,IAC7C,WAAW,EAAE,OAAO,IAAIA,iBAAM,QAAO,EAAI;AAAA,IACzC,YAAY,EAAE,OAAO,IAAIA,iBAAM,QAAO,EAAI;AAAA,IAC1C,MAAM,EAAE,OAAO,EAAK;AAAA,IACpB,GAAG,EAAE,OAAO,EAAK;AAAA,IACjB,WAAW,EAAE,OAAO,KAAM;AAAA,IAC1B,QAAQ,EAAE,OAAO,GAAM;AAAA,IACvB,aAAa,EAAE,OAAO,EAAK;AAAA,IAC3B,OAAO,EAAE,OAAO,EAAK;AAAA,IACrB,aAAa,EAAE,OAAO,GAAI;AAAA,IAC1B,iBAAiB,EAAE,OAAO,EAAK;AAAA,IAC/B,MAAM,EAAE,OAAO,IAAK;AAAA,IACpB,KAAK,EAAE,OAAO,IAAQ;AAAA,IACtB,UAAU,EAAE,OAAO,MAAO;AAAA,IAC1B,mBAAmB,EAAE,OAAO,MAAO;AAAA,EACpC;AAAA,EACD,YAAY;AAAA,EACZ,WAAW;AAAA,EAEX;AAAA;AAAA,IAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMzB;AAAA;AAAA,IAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6H7B;;"}
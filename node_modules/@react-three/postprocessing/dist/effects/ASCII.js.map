{"version":3,"file":"ASCII.js","sources":["../../src/effects/ASCII.tsx"],"sourcesContent":["// From: https://github.com/emilwidlund/ASCII\n// https://twitter.com/emilwidlund/status/1652386482420609024\n\nimport { forwardRef, useMemo } from 'react'\nimport { CanvasTexture, Color, NearestFilter, RepeatWrapping, Texture, Uniform } from 'three'\nimport { Effect } from 'postprocessing'\n\nconst fragment = `\nuniform sampler2D uCharacters;\nuniform float uCharactersCount;\nuniform float uCellSize;\nuniform bool uInvert;\nuniform vec3 uColor;\n\nconst vec2 SIZE = vec2(16.);\n\nvec3 greyscale(vec3 color, float strength) {\n    float g = dot(color, vec3(0.299, 0.587, 0.114));\n    return mix(color, vec3(g), strength);\n}\n\nvec3 greyscale(vec3 color) {\n    return greyscale(color, 1.0);\n}\n\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n    vec2 cell = resolution / uCellSize;\n    vec2 grid = 1.0 / cell;\n    vec2 pixelizedUV = grid * (0.5 + floor(uv / grid));\n    vec4 pixelized = texture2D(inputBuffer, pixelizedUV);\n    float greyscaled = greyscale(pixelized.rgb).r;\n\n    if (uInvert) {\n        greyscaled = 1.0 - greyscaled;\n    }\n\n    float characterIndex = floor((uCharactersCount - 1.0) * greyscaled);\n    vec2 characterPosition = vec2(mod(characterIndex, SIZE.x), floor(characterIndex / SIZE.y));\n    vec2 offset = vec2(characterPosition.x, -characterPosition.y) / SIZE;\n    vec2 charUV = mod(uv * (cell / SIZE), 1.0 / SIZE) - vec2(0., 1.0 / SIZE) + offset;\n    vec4 asciiCharacter = texture2D(uCharacters, charUV);\n\n    asciiCharacter.rgb = uColor * asciiCharacter.r;\n    asciiCharacter.a = pixelized.a;\n    outputColor = asciiCharacter;\n}\n`\n\ninterface IASCIIEffectProps {\n  font?: string\n  characters?: string\n  fontSize?: number\n  cellSize?: number\n  color?: string\n  invert?: boolean\n}\n\nclass ASCIIEffect extends Effect {\n  constructor({\n    font = 'arial',\n    characters = ` .:,'-^=*+?!|0#X%WM@`,\n    fontSize = 54,\n    cellSize = 16,\n    color = '#ffffff',\n    invert = false,\n  }: IASCIIEffectProps = {}) {\n    const uniforms = new Map<string, Uniform>([\n      ['uCharacters', new Uniform(new Texture())],\n      ['uCellSize', new Uniform(cellSize)],\n      ['uCharactersCount', new Uniform(characters.length)],\n      ['uColor', new Uniform(new Color(color))],\n      ['uInvert', new Uniform(invert)],\n    ])\n\n    super('ASCIIEffect', fragment, { uniforms })\n\n    const charactersTextureUniform = this.uniforms.get('uCharacters')\n\n    if (charactersTextureUniform) {\n      charactersTextureUniform.value = this.createCharactersTexture(characters, font, fontSize)\n    }\n  }\n\n  /** Draws the characters on a Canvas and returns a texture */\n  public createCharactersTexture(characters: string, font: string, fontSize: number): THREE.Texture {\n    const canvas = document.createElement('canvas')\n    const SIZE = 1024\n    const MAX_PER_ROW = 16\n    const CELL = SIZE / MAX_PER_ROW\n\n    canvas.width = canvas.height = SIZE\n    const texture = new CanvasTexture(canvas, undefined, RepeatWrapping, RepeatWrapping, NearestFilter, NearestFilter)\n    const context = canvas.getContext('2d')\n\n    if (!context) {\n      throw new Error('Context not available')\n    }\n\n    context.clearRect(0, 0, SIZE, SIZE)\n    context.font = `${fontSize}px ${font}`\n    context.textAlign = 'center'\n    context.textBaseline = 'middle'\n    context.fillStyle = '#fff'\n\n    for (let i = 0; i < characters.length; i++) {\n      const char = characters[i]\n      const x = i % MAX_PER_ROW\n      const y = Math.floor(i / MAX_PER_ROW)\n      context.fillText(char, x * CELL + CELL / 2, y * CELL + CELL / 2)\n    }\n\n    texture.needsUpdate = true\n    return texture\n  }\n}\n\nexport const ASCII = forwardRef<ASCIIEffect, IASCIIEffectProps>(\n  (\n    {\n      font = 'arial',\n      characters = ` .:,'-^=*+?!|0#X%WM@`,\n      fontSize = 54,\n      cellSize = 16,\n      color = '#ffffff',\n      invert = false,\n    },\n    fref\n  ) => {\n    const effect = useMemo(\n      () => new ASCIIEffect({ characters, font, fontSize, cellSize, color, invert }),\n      [characters, fontSize, cellSize, color, invert, font]\n    )\n    return <primitive ref={fref} object={effect} />\n  }\n)\n"],"names":[],"mappings":";;;;AAOA,MAAM,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkDjB,MAAM,oBAAoB,OAAO;AAAA,EAC/B,YAAY;AAAA,IACV,OAAO;AAAA,IACP,aAAa;AAAA,IACb,WAAW;AAAA,IACX,WAAW;AAAA,IACX,QAAQ;AAAA,IACR,SAAS;AAAA,EACX,IAAuB,IAAI;AACnB,UAAA,+BAAe,IAAqB;AAAA,MACxC,CAAC,eAAe,IAAI,QAAQ,IAAI,QAAS,CAAA,CAAC;AAAA,MAC1C,CAAC,aAAa,IAAI,QAAQ,QAAQ,CAAC;AAAA,MACnC,CAAC,oBAAoB,IAAI,QAAQ,WAAW,MAAM,CAAC;AAAA,MACnD,CAAC,UAAU,IAAI,QAAQ,IAAI,MAAM,KAAK,CAAC,CAAC;AAAA,MACxC,CAAC,WAAW,IAAI,QAAQ,MAAM,CAAC;AAAA,IAAA,CAChC;AAED,UAAM,eAAe,UAAU,EAAE,SAAU,CAAA;AAE3C,UAAM,2BAA2B,KAAK,SAAS,IAAI,aAAa;AAEhE,QAAI,0BAA0B;AAC5B,+BAAyB,QAAQ,KAAK,wBAAwB,YAAY,MAAM,QAAQ;AAAA,IAC1F;AAAA,EACF;AAAA;AAAA,EAGO,wBAAwB,YAAoB,MAAc,UAAiC;AAC1F,UAAA,SAAS,SAAS,cAAc,QAAQ;AAC9C,UAAM,OAAO;AACb,UAAM,cAAc;AACpB,UAAM,OAAO,OAAO;AAEb,WAAA,QAAQ,OAAO,SAAS;AACzB,UAAA,UAAU,IAAI,cAAc,QAAQ,QAAW,gBAAgB,gBAAgB,eAAe,aAAa;AAC3G,UAAA,UAAU,OAAO,WAAW,IAAI;AAEtC,QAAI,CAAC,SAAS;AACN,YAAA,IAAI,MAAM,uBAAuB;AAAA,IACzC;AAEA,YAAQ,UAAU,GAAG,GAAG,MAAM,IAAI;AAC1B,YAAA,OAAO,GAAG,cAAc;AAChC,YAAQ,YAAY;AACpB,YAAQ,eAAe;AACvB,YAAQ,YAAY;AAEpB,aAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AACpC,YAAA,OAAO,WAAW,CAAC;AACzB,YAAM,IAAI,IAAI;AACd,YAAM,IAAI,KAAK,MAAM,IAAI,WAAW;AAC5B,cAAA,SAAS,MAAM,IAAI,OAAO,OAAO,GAAG,IAAI,OAAO,OAAO,CAAC;AAAA,IACjE;AAEA,YAAQ,cAAc;AACf,WAAA;AAAA,EACT;AACF;AAEO,MAAM,QAAQ;AAAA,EACnB,CACE;AAAA,IACE,OAAO;AAAA,IACP,aAAa;AAAA,IACb,WAAW;AAAA,IACX,WAAW;AAAA,IACX,QAAQ;AAAA,IACR,SAAS;AAAA,KAEX,SACG;AACH,UAAM,SAAS;AAAA,MACb,MAAM,IAAI,YAAY,EAAE,YAAY,MAAM,UAAU,UAAU,OAAO,QAAQ;AAAA,MAC7E,CAAC,YAAY,UAAU,UAAU,OAAO,QAAQ,IAAI;AAAA,IAAA;AAEtD,WAAQ,oBAAA,aAAA,EAAU,KAAK,MAAM,QAAQ,OAAQ,CAAA;AAAA,EAC/C;AACF;"}
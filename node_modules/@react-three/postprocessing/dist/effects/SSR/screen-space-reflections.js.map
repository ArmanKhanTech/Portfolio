{"version":3,"file":"screen-space-reflections.js","sources":["../../../src/effects/SSR/screen-space-reflections.js"],"sourcesContent":["import { Pass, RenderPass, DepthPass, Effect, Selection } from 'postprocessing'\nimport {\n  REVISION,\n  ShaderMaterial,\n  Uniform,\n  Vector2,\n  Matrix3,\n  TangentSpaceNormalMap,\n  GLSL3,\n  Matrix4,\n  Vector3,\n  WebGLRenderTarget,\n  LinearFilter,\n  HalfFloatType,\n  WebGLMultipleRenderTargets,\n  ShaderChunk,\n  Color,\n  Quaternion,\n  VideoTexture,\n  DataTexture,\n  RGBAFormat,\n  FloatType,\n  NearestFilter,\n  FramebufferTexture,\n  WebGLCubeRenderTarget,\n  CubeCamera,\n  PMREMGenerator,\n  Texture,\n} from 'three'\n\nconst boxBlur = /* glsl */ `\n  uniform float blur;\n  uniform float blurSharpness;\n  uniform int blurKernel;\n\n  vec3 denoise(\n    vec3 center,\n    sampler2D tex,\n    vec2 uv,\n    vec2 invTexSize,\n    float blur,\n    float blurSharpness,\n    int blurKernel\n  ) {\n    vec3 color, col;\n    float total, weight;\n\n    for (int x = -blurKernel; x <= blurKernel; x++) {\n      for (int y=-blurKernel; y<=blurKernel; y++) {\n        col = textureLod(tex, uv + vec2(x,y) * invTexSize, 0.0).rgb;\n        weight = 1.0-abs(dot(col - center, vec3(0.25)));\n        weight = pow(weight, blurSharpness);\n        color += col * weight;\n        total += weight;\n      }\n    }\n\n    return color / total;\n  }\n`\n\nconst finalSSRShader = /* glsl */ `\n  #define MODE_DEFAULT 0\n  #define MODE_REFLECTIONS 1\n  #define MODE_RAW_REFLECTION 2\n  #define MODE_BLURRED_REFLECTIONS 3\n  #define MODE_INPUT 4\n  #define MODE_BLUR_MIX 5\n  #define FLOAT_EPSILON 0.00001\n  // uniform sampler2D inputTexture;\n  uniform sampler2D reflectionsTexture;\n  // uniform float samples;\n\n  ${boxBlur}\n\n  void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n    vec4 reflectionsTexel=texture2D(reflectionsTexture, vUv);\n    ivec2 size = textureSize(reflectionsTexture, 0);\n    vec2 invTexSize= 1.0 / vec2(size.x, size.y);\n    vec3 reflectionClr = reflectionsTexel.xyz;\n    if (blur > FLOAT_EPSILON) {\n      vec3 blurredReflectionsColor = denoise(\n        reflectionsTexel.rgb,\n        reflectionsTexture,\n        vUv,\n        invTexSize,\n        blur,\n        blurSharpness,\n        blurKernel\n      );\n      reflectionClr = mix(reflectionClr, blurredReflectionsColor.rgb, blur);\n    }\n\n    #if RENDER_MODE == MODE_DEFAULT\n      outputColor = vec4(inputColor.rgb+reflectionClr, 1.0);\n    #endif\n    #if RENDER_MODE == MODE_REFLECTIONS\n      outputColor = vec4(reflectionClr, 1.0);\n    #endif\n    #if RENDER_MODE == MODE_RAW_REFLECTION\n      outputColor = vec4(reflectionsTexel.xyz, 1.0);\n    #endif\n    #if RENDER_MODE == MODE_BLURRED_REFLECTIONS\n      outputColor = vec4(blurredReflectionsTexel.xyz, 1.0);\n    #endif\n    #if RENDER_MODE == MODE_INPUT\n      outputColor = vec4(inputColor.xyz, 1.0);\n    #endif\n    #if RENDER_MODE == MODE_BLUR_MIX\n      outputColor = vec4(vec3(blur), 1.0);\n    #endif\n  }\n`\n\nconst helperFunctions = /* glsl */ `\n  vec3 getViewPosition(const float depth) {\n    float clipW= _projectionMatrix[2][3] * depth + _projectionMatrix[3][3];\n    vec4 clipPosition = vec4((vec3(vUv, depth) - 0.5) * 2.0, 1.0);\n    clipPosition *= clipW;\n    return(_inverseProjectionMatrix * clipPosition).xyz;\n  }\n\n  float getViewZ(const in float depth) {\n    #ifdef PERSPECTIVE_CAMERA\n      return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n    #else\n      return orthographicDepthToViewZ(depth, cameraNear, cameraFar);\n    #endif\n  }\n\n  vec3 screenSpaceToWorldSpace(const vec2 uv,const float depth){\n    vec4 ndc = vec4((uv.x - 0.5) * 2.0,(uv.y - 0.5)* 2.0, (depth - 0.5) * 2.0, 1.0);\n    vec4 clip= _inverseProjectionMatrix*ndc;\n    vec4 view = cameraMatrixWorld * (clip / clip.w);\n    return view.xyz;\n  }\n\n  #define Scale (vec3(0.8, 0.8, 0.8))\n  #define K (19.19)\n\n  vec3 hash(vec3 a) {\n    a = fract(a * Scale);\n    a += dot(a, a.yxz + K);\n    return fract((a.xxy + a.yxx) * a.zyx);\n  }\n\n  float fresnel_dielectric_cos(float cosi, float eta){\n    float c = abs(cosi);\n    float g = eta * eta - 1.0 +  c* c;\n    float result;\n\n    if (g > 0.0){\n      g = sqrt(g);\n      float A = (g - c) / (g + c);\n      float B = (c* (g + c) - 1.0) / (c * (g - c) + 1.0);\n      result = 0.5 * A * A * (1.0 + B * B);\n    } else {\n      result = 1.0;\n    }\n    \n    return result;\n  }\n\n  float fresnel_dielectric(vec3 Incoming, vec3 Normal, float eta){\n    float cosine = dot(Incoming, Normal);\n    return min(1.0, 5.0 * fresnel_dielectric_cos(cosine, eta));\n  }\n`\n\nconst trCompose = /* glsl */ `\n  #define INV_EULER 0.36787944117144233\n\n  alpha = velocityDisocclusion < FLOAT_EPSILON ? (alpha + 0.0075) : 0.0;\n  alpha = clamp(alpha, 0.0, 1.0);\n  bool needsBlur = !didReproject || velocityDisocclusion > 0.5;\n\n  #ifdef boxBlur\n    if (needsBlur) inputColor = boxBlurredColor;\n  #endif\n\n  if (alpha == 1.0) {\n    outputColor = accumulatedColor;\n  } else {\n    float m = mix(alpha, 1.0, blend);\n    if (needsBlur) m = 0.0;\n    outputColor = accumulatedColor * m + inputColor * (1.0 - m);\n  }\n`\n\n// WebGL2: will render normals to RGB channel of \"gNormal\" buffer, roughness to A channel of \"gNormal\" buffer, depth to RGBA channel of \"gDepth\" buffer\n// and velocity to \"gVelocity\" buffer\n\nclass MRTMaterial extends ShaderMaterial {\n  constructor() {\n    super({\n      type: 'MRTMaterial',\n      defines: {\n        USE_UV: '',\n        TEMPORAL_RESOLVE: '',\n      },\n      uniforms: {\n        opacity: new Uniform(1),\n        normalMap: new Uniform(null),\n        normalScale: new Uniform(new Vector2(1, 1)),\n        uvTransform: new Uniform(new Matrix3()),\n        roughness: new Uniform(1),\n        roughnessMap: new Uniform(null),\n      },\n      vertexShader: /* glsl */ `\n        #ifdef USE_MRT\n          varying vec2 vHighPrecisionZW;\n        #endif\n        #define NORMAL\n        #if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(TANGENTSPACE_NORMALMAP)\n          varying vec3 vViewPosition;\n        #endif\n        #include <common>\n        #include <uv_pars_vertex>\n        #include <displacementmap_pars_vertex>\n        #include <normal_pars_vertex>\n        #include <morphtarget_pars_vertex>\n        #include <skinning_pars_vertex>\n        #include <logdepthbuf_pars_vertex>\n        #include <clipping_planes_pars_vertex>\n        #ifdef USE_UV\n          ${REVISION.replace(/\\D+/g, '') >= 151 ? 'uniform mat3 uvTransform;' : ''}\n        #endif\n        void main() {\n          #include <uv_vertex>\n          #include <beginnormal_vertex>\n          #include <morphnormal_vertex>\n          #include <skinbase_vertex>\n          #include <skinnormal_vertex>\n          #include <defaultnormal_vertex>\n          #include <normal_vertex>\n          #include <begin_vertex>\n          #include <morphtarget_vertex>\n          #include <skinning_vertex>\n          #include <displacementmap_vertex>\n          #include <project_vertex>\n          #include <logdepthbuf_vertex>\n          #include <clipping_planes_vertex>\n          #if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(TANGENTSPACE_NORMALMAP)\n            vViewPosition = -mvPosition.xyz;\n          #endif\n          #ifdef USE_MRT\n            vHighPrecisionZW = gl_Position.zw;\n          #endif\n          #ifdef USE_UV\n            vUv = (uvTransform * vec3(uv, 1)).xy;\n          #endif\n        }\n      `,\n      fragmentShader: /* glsl */ `\n        #define NORMAL\n        #if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(TANGENTSPACE_NORMALMAP)\n          varying vec3 vViewPosition;\n        #endif\n        #include <packing>\n        #include <uv_pars_fragment>\n        #include <normal_pars_fragment>\n        #include <bumpmap_pars_fragment>\n        #include <normalmap_pars_fragment>\n        #include <logdepthbuf_pars_fragment>\n        #include <clipping_planes_pars_fragment>\n        #include <roughnessmap_pars_fragment>\n\n        #ifdef USE_MRT\n          layout(location = 0) out vec4 gNormal;\n          layout(location = 1) out vec4 gDepth;\n          varying vec2 vHighPrecisionZW;\n        #endif\n        uniform float roughness;\n        void main() {\n          #include <clipping_planes_fragment>\n          #include <logdepthbuf_fragment>\n          #include <normal_fragment_begin>\n          #include <normal_fragment_maps>\n\n          float roughnessFactor = roughness;\n\n          if (roughness > 10.0e9){\n            roughnessFactor = 1.;\n          } else {\n            #ifdef useRoughnessMap\n              vec4 texelRoughness = texture2D(roughnessMap, vUv);\n              // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n              roughnessFactor *= texelRoughness.g;\n            #endif\n          }\n\n          vec3 normalColor = packNormalToRGB(normal);\n          #ifdef USE_MRT\n            float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n            vec4 depthColor = packDepthToRGBA(fragCoordZ);\n            gNormal = vec4(normalColor, roughnessFactor);\n            gDepth = depthColor;\n          #else\n            gl_FragColor = vec4(normalColor, roughnessFactor);\n          #endif\n        }\n      `,\n      toneMapped: false,\n    })\n    this.normalMapType = TangentSpaceNormalMap\n    this.normalScale = new Vector2(1, 1)\n    Object.defineProperty(this, 'glslVersion', {\n      get() {\n        return 'USE_MRT' in this.defines ? GLSL3 : null\n      },\n      set(_) {},\n    })\n  }\n}\n\nconst vertexShader = /* glsl */ `\n  varying vec2 vUv;\n\n  void main() {\n    vUv = position.xy * 0.5 + 0.5;\n    gl_Position = vec4(position.xy, 1.0, 1.0);\n  }\n`\n\nconst fragmentShader = /* glsl */ `\n  varying vec2 vUv;\n  uniform sampler2D inputTexture;\n  uniform sampler2D accumulatedTexture;\n  uniform sampler2D normalTexture;\n  uniform sampler2D depthTexture;\n  uniform sampler2D envMap;\n  uniform mat4 _projectionMatrix;\n  uniform mat4 _inverseProjectionMatrix;\n  uniform mat4 cameraMatrixWorld;\n  uniform float cameraNear;\n  uniform float cameraFar;\n  uniform float rayDistance;\n  uniform float intensity;\n  uniform float maxDepthDifference;\n  uniform float roughnessFade;\n  uniform float maxRoughness;\n  uniform float fade;\n  uniform float thickness;\n  uniform float ior;\n  uniform float samples;\n  uniform float jitter;\n  uniform float jitterRoughness;\n\n  #define INVALID_RAY_COORDS vec2(-1.0);\n\n  #define EARLY_OUT_COLOR vec4(0.0, 0.0, 0.0, 1.0)\n  #define FLOAT_EPSILON 0.00001\n  float nearMinusFar;\n  float nearMulFar;\n  float farMinusNear;\n\n  #include <packing>\n\n  ${helperFunctions}\n\n  vec2 RayMarch(vec3 dir, inout vec3 hitPos, inout float rayHitDepthDifference);\n  vec2 BinarySearch(in vec3 dir, inout vec3 hitPos, inout float rayHitDepthDifference);\n  float fastGetViewZ(const in float depth);\n  vec3 getIBLRadiance(const in vec3 viewDir, const in vec3 normal, const in float roughness);\n\n  void main() {\n    vec4 depthTexel = textureLod(depthTexture, vUv, 0.0);\n\n    if (dot(depthTexel.rgb, depthTexel.rgb) < FLOAT_EPSILON) {\n      gl_FragColor = EARLY_OUT_COLOR;\n      return;\n    }\n\n    float unpackedDepth = unpackRGBAToDepth(depthTexel);\n    vec4 normalTexel = textureLod(normalTexture, vUv, 0.0);\n    float roughness = normalTexel.a;\n    float specular = 1.0 - roughness;\n\n    nearMinusFar = cameraNear - cameraFar;\n    nearMulFar = cameraNear * cameraFar;\n    farMinusNear = cameraFar - cameraNear;\n\n    normalTexel.rgb = unpackRGBToNormal(normalTexel.rgb);\n\n    float depth = fastGetViewZ(unpackedDepth);\n    vec3 viewPos = getViewPosition(depth);\n    vec3 viewDir = normalize(viewPos);\n    vec3 viewNormal = normalTexel.xyz;\n    vec3 worldPos = screenSpaceToWorldSpace(vUv, unpackedDepth);\n\n    vec3 jitt=vec3(0.0);\n    if (jitterRoughness != 0.0 || jitter!=0.0){\n      vec3 randomJitter = hash(50.0 * samples * worldPos) - 0.5;\n      float spread= ((2.0 - specular) + roughness * jitterRoughness);\n      float jitterMix = jitter * 0.25 + jitterRoughness * roughness;\n      if (jitterMix > 1.0) jitterMix = 1.0;\n      jitt = mix(vec3(0.0), randomJitter * spread, jitterMix);\n    }\n    \n    viewNormal += jitt;\n    float fresnelFactor = fresnel_dielectric(viewDir, viewNormal, ior);\n    vec3 iblRadiance = getIBLRadiance(-viewDir, viewNormal, 0.0) * fresnelFactor;\n    float lastFrameAlpha = textureLod(accumulatedTexture, vUv, 0.0).a;\n    if (roughness > maxRoughness || (roughness > 1.0 - FLOAT_EPSILON && roughnessFade > 1.0 - FLOAT_EPSILON)) {\n      gl_FragColor=vec4(iblRadiance,lastFrameAlpha);\n      return;\n    }\n    \n    vec3 reflected = reflect(viewDir, viewNormal);\n    vec3 rayDir = reflected *- viewPos.z;\n    vec3 hitPos = viewPos;\n    float rayHitDepthDifference;\n    vec2 coords = RayMarch(rayDir, hitPos, rayHitDepthDifference);\n    if (coords.x == -1.0){\n      gl_FragColor=vec4(iblRadiance, lastFrameAlpha);\n      return;\n    }\n    \n    vec4 SSRTexel = textureLod(inputTexture, coords.xy, 0.0);\n    vec4 SSRTexelReflected = textureLod(accumulatedTexture, coords.xy, 0.0);\n    vec3 SSR = SSRTexel.rgb + SSRTexelReflected.rgb;\n    float roughnessFactor = mix(specular, 1.0, max(0.0, 1.0 - roughnessFade));\n    vec2 coordsNDC = (coords.xy * 2.0 - 1.0);\n    float screenFade = 0.1;\n    float maxDimension = min(1.0, max(abs(coordsNDC.x), abs(coordsNDC.y)));\n    float reflectionIntensity = 1.0 - (max(0.0, maxDimension - screenFade) / (1.0 - screenFade));\n    reflectionIntensity = max(0.0, reflectionIntensity);\n    vec3 finalSSR = mix(iblRadiance, SSR, reflectionIntensity) * roughnessFactor;\n\n    if (fade != 0.0) {\n      vec3 hitWorldPos = screenSpaceToWorldSpace(coords, rayHitDepthDifference);\n      float reflectionDistance = distance(hitWorldPos, worldPos) + 1.0;\n      float opacity = 1.0 / (reflectionDistance * fade * 0.1);\n      if(opacity > 1.0) opacity=1.0;\n      finalSSR *= opacity;\n    }\n\n    finalSSR *= fresnelFactor * intensity;\n    finalSSR = min(vec3(1.0), finalSSR);\n    float alpha = hitPos.z == 1.0 ? 1.0 : SSRTexelReflected.a;\n    alpha = min(lastFrameAlpha, alpha);\n    gl_FragColor = vec4(finalSSR, alpha);\n  }\n\n  vec2 RayMarch(vec3 dir, inout vec3 hitPos, inout float rayHitDepthDifference) {\n    dir=normalize(dir);\n    dir *= rayDistance / float(steps);\n    float depth;\n    vec4 projectedCoord;\n    vec4 lastProjectedCoord;\n    float unpackedDepth;\n    vec4 depthTexel;\n\n    for (int i = 0; i < steps; i++) {\n      hitPos += dir;\n      projectedCoord = _projectionMatrix * vec4(hitPos, 1.0);\n      projectedCoord.xy /= projectedCoord.w;\n      projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;\n\n      #ifndef missedRays\n        if (\n          projectedCoord.x < 0.0 ||\n          projectedCoord.x > 1.0 ||\n          projectedCoord.y < 0.0 ||\n          projectedCoord.y > 1.0\n        ) {\n          return INVALID_RAY_COORDS;\n        }\n      #endif\n\n      depthTexel = textureLod(depthTexture, projectedCoord.xy, 0.0);\n      unpackedDepth = unpackRGBAToDepth(depthTexel);\n      depth = fastGetViewZ(unpackedDepth);\n      rayHitDepthDifference = depth - hitPos.z;\n\n      if (rayHitDepthDifference >= 0.0 && rayHitDepthDifference < thickness){\n        #if refineSteps == 0\n          if (dot(depthTexel.rgb, depthTexel.rgb) < FLOAT_EPSILON) return INVALID_RAY_COORDS;\n        #else\n          return BinarySearch(dir, hitPos, rayHitDepthDifference);\n        #endif\n      }\n\n      #ifndef missedRays\n        if (hitPos.z > 0.0) return INVALID_RAY_COORDS;\n      #endif\n\n      lastProjectedCoord = projectedCoord;\n    }\n    \n    hitPos.z = 1.0;\n\n    #ifndef missedRays\n      return INVALID_RAY_COORDS;\n    #endif\n\n    rayHitDepthDifference = unpackedDepth;\n\n    return projectedCoord.xy;\n  }\n\n  vec2 BinarySearch(in vec3 dir, inout vec3 hitPos, inout float rayHitDepthDifference) {\n    float depth;\n    vec4 projectedCoord;\n    vec2 lastMinProjectedCoordXY;\n    float unpackedDepth;\n    vec4 depthTexel;\n\n    for (int i = 0; i < refineSteps; i++){\n      projectedCoord = _projectionMatrix * vec4(hitPos, 1.0);\n      projectedCoord.xy /= projectedCoord.w;\n      projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;\n      depthTexel = textureLod(depthTexture, projectedCoord.xy, 0.0);\n      unpackedDepth = unpackRGBAToDepth(depthTexel);\n      depth = fastGetViewZ(unpackedDepth);\n      rayHitDepthDifference = depth - hitPos.z;\n      dir *= 0.5;\n\n      if (rayHitDepthDifference > 0.0) {\n        hitPos -= dir;\n      } else {\n        hitPos += dir;\n      }\n    }\n    \n    if (dot(depthTexel.rgb, depthTexel.rgb) < FLOAT_EPSILON) return INVALID_RAY_COORDS;\n    if (abs(rayHitDepthDifference) > maxDepthDifference) return INVALID_RAY_COORDS;\n\n    projectedCoord = _projectionMatrix*vec4(hitPos, 1.0);\n    projectedCoord.xy /= projectedCoord.w;\n    projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;\n    rayHitDepthDifference = unpackedDepth;\n    return projectedCoord.xy;\n  }\n\n  float fastGetViewZ(const in float depth){\n    #ifdef PERSPECTIVE_CAMERA\n      return nearMulFar / (farMinusNear * depth - cameraFar);\n    #else\n      return depth * nearMinusFar - cameraNear;\n    #endif\n  }\n\n  #include <common>\n  #include <cube_uv_reflection_fragment>\n\n  vec3 getIBLRadiance(const in vec3 viewDir, const in vec3 normal, const in float roughness){\n    #if defined(ENVMAP_TYPE_CUBE_UV)\n      vec3 reflectVec = reflect(-viewDir, normal);\n      reflectVec = normalize(mix(reflectVec, normal,roughness * roughness));\n      reflectVec = inverseTransformDirection(reflectVec, viewMatrix);\n      vec4 envMapColor = textureCubeUV(envMap, reflectVec, roughness);\n      return envMapColor.rgb * intensity;\n    #else\n      return vec3(0.0);\n    #endif\n  }\n`\n\nclass ReflectionsMaterial extends ShaderMaterial {\n  constructor() {\n    super({\n      type: 'ReflectionsMaterial',\n      uniforms: {\n        inputTexture: new Uniform(null),\n        accumulatedTexture: new Uniform(null),\n        normalTexture: new Uniform(null),\n        depthTexture: new Uniform(null),\n        _projectionMatrix: new Uniform(new Matrix4()),\n        _inverseProjectionMatrix: new Uniform(new Matrix4()),\n        cameraMatrixWorld: new Uniform(new Matrix4()),\n        cameraNear: new Uniform(0),\n        cameraFar: new Uniform(0),\n        rayDistance: new Uniform(0),\n        intensity: new Uniform(0),\n        roughnessFade: new Uniform(0),\n        fade: new Uniform(0),\n        thickness: new Uniform(0),\n        ior: new Uniform(0),\n        maxDepthDifference: new Uniform(0),\n        jitter: new Uniform(0),\n        jitterRoughness: new Uniform(0),\n        maxRoughness: new Uniform(0),\n        samples: new Uniform(0),\n        envMap: new Uniform(null),\n        envMapPosition: new Uniform(new Vector3()),\n        envMapSize: new Uniform(new Vector3()),\n        viewMatrix: new Uniform(new Matrix4()),\n      },\n      defines: {\n        steps: 20,\n        refineSteps: 5,\n        CUBEUV_TEXEL_WIDTH: 0,\n        CUBEUV_TEXEL_HEIGHT: 0,\n        CUBEUV_MAX_MIP: 0,\n        vWorldPosition: 'worldPos',\n      },\n      fragmentShader,\n      vertexShader,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n    })\n  }\n}\n\nconst getVisibleChildren = (object) => {\n  const queue = [object]\n  const objects = []\n\n  while (queue.length !== 0) {\n    const mesh = queue.shift()\n    if (mesh.material) objects.push(mesh)\n\n    for (const c of mesh.children) {\n      if (c.visible) queue.push(c)\n    }\n  }\n\n  return objects\n}\nconst generateCubeUVSize = (parameters) => {\n  const imageHeight = parameters.envMapCubeUVHeight\n  if (imageHeight === null) return null\n  const maxMip = Math.log2(imageHeight) - 2\n  const texelHeight = 1.0 / imageHeight\n  const texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16))\n  return {\n    texelWidth,\n    texelHeight,\n    maxMip,\n  }\n}\nconst setupEnvMap = (reflectionsMaterial, envMap, envMapCubeUVHeight) => {\n  reflectionsMaterial.uniforms.envMap.value = envMap\n  const envMapCubeUVSize = generateCubeUVSize({\n    envMapCubeUVHeight,\n  })\n  reflectionsMaterial.defines.ENVMAP_TYPE_CUBE_UV = ''\n  reflectionsMaterial.defines.CUBEUV_TEXEL_WIDTH = envMapCubeUVSize.texelWidth\n  reflectionsMaterial.defines.CUBEUV_TEXEL_HEIGHT = envMapCubeUVSize.texelHeight\n  reflectionsMaterial.defines.CUBEUV_MAX_MIP = envMapCubeUVSize.maxMip + '.0'\n  reflectionsMaterial.needsUpdate = true\n}\n\nconst isWebGL2Available = () => {\n  try {\n    const canvas = document.createElement('canvas')\n    return !!(window.WebGL2RenderingContext && canvas.getContext('webgl2'))\n  } catch (e) {\n    return false\n  }\n}\n\nclass ReflectionsPass extends Pass {\n  constructor(ssrEffect, options = {}) {\n    super('ReflectionsPass')\n    this.ssrEffect = void 0\n    this.cachedMaterials = new WeakMap()\n    this.USE_MRT = false\n    this.webgl1DepthPass = null\n    this.visibleMeshes = []\n    this.ssrEffect = ssrEffect\n    this._scene = ssrEffect._scene\n    this._camera = ssrEffect._camera\n    this.fullscreenMaterial = new ReflectionsMaterial()\n    if (ssrEffect._camera.isPerspectiveCamera) this.fullscreenMaterial.defines.PERSPECTIVE_CAMERA = ''\n    const width = options.width || typeof window !== 'undefined' ? window.innerWidth : 2000\n    const height = options.height || typeof window !== 'undefined' ? window.innerHeight : 1000\n    this.renderTarget = new WebGLRenderTarget(width, height, {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      type: HalfFloatType,\n      depthBuffer: false,\n    })\n    this.renderPass = new RenderPass(this._scene, this._camera)\n    this.USE_MRT = isWebGL2Available()\n\n    if (this.USE_MRT) {\n      // buffers: normal, depth (2), roughness will be written to the alpha channel of the normal buffer\n      this.gBuffersRenderTarget = new WebGLMultipleRenderTargets(width, height, 2, {\n        minFilter: LinearFilter,\n        magFilter: LinearFilter,\n      })\n      this.normalTexture = this.gBuffersRenderTarget.texture[0]\n      this.depthTexture = this.gBuffersRenderTarget.texture[1]\n    } else {\n      // depth pass\n      this.webgl1DepthPass = new DepthPass(this._scene, this._camera)\n      this.webgl1DepthPass.renderTarget.minFilter = LinearFilter\n      this.webgl1DepthPass.renderTarget.magFilter = LinearFilter\n      this.webgl1DepthPass.renderTarget.texture.minFilter = LinearFilter\n      this.webgl1DepthPass.renderTarget.texture.magFilter = LinearFilter\n      this.webgl1DepthPass.setSize(\n        typeof window !== 'undefined' ? window.innerWidth : 2000,\n        typeof window !== 'undefined' ? window.innerHeight : 1000\n      ) // render normals (in the rgb channel) and roughness (in the alpha channel) in gBuffersRenderTarget\n\n      this.gBuffersRenderTarget = new WebGLRenderTarget(width, height, {\n        minFilter: LinearFilter,\n        magFilter: LinearFilter,\n      })\n      this.normalTexture = this.gBuffersRenderTarget.texture\n      this.depthTexture = this.webgl1DepthPass.texture\n    } // set up uniforms\n\n    this.fullscreenMaterial.uniforms.normalTexture.value = this.normalTexture\n    this.fullscreenMaterial.uniforms.depthTexture.value = this.depthTexture\n    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssrEffect.temporalResolvePass.accumulatedTexture\n    this.fullscreenMaterial.uniforms.cameraMatrixWorld.value = this._camera.matrixWorld\n    this.fullscreenMaterial.uniforms._projectionMatrix.value = this._camera.projectionMatrix\n    this.fullscreenMaterial.uniforms._inverseProjectionMatrix.value = this._camera.projectionMatrixInverse\n  }\n\n  setSize(width, height) {\n    this.renderTarget.setSize(width * this.ssrEffect.resolutionScale, height * this.ssrEffect.resolutionScale)\n    this.gBuffersRenderTarget.setSize(width * this.ssrEffect.resolutionScale, height * this.ssrEffect.resolutionScale)\n    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssrEffect.temporalResolvePass.accumulatedTexture\n    this.fullscreenMaterial.needsUpdate = true\n  }\n\n  dispose() {\n    this.renderTarget.dispose()\n    this.gBuffersRenderTarget.dispose()\n    this.renderPass.dispose()\n    if (!this.USE_MRT) this.webgl1DepthPass.dispose()\n    this.fullscreenMaterial.dispose()\n    this.normalTexture = null\n    this.depthTexture = null\n    this.velocityTexture = null\n  }\n\n  keepMaterialMapUpdated(mrtMaterial, originalMaterial, prop, define) {\n    if (this.ssrEffect[define]) {\n      if (originalMaterial[prop] !== mrtMaterial[prop]) {\n        mrtMaterial[prop] = originalMaterial[prop]\n        mrtMaterial.uniforms[prop].value = originalMaterial[prop]\n\n        if (originalMaterial[prop]) {\n          mrtMaterial.defines[define] = ''\n        } else {\n          delete mrtMaterial.defines[define]\n        }\n\n        mrtMaterial.needsUpdate = true\n      }\n    } else if (mrtMaterial[prop] !== undefined) {\n      mrtMaterial[prop] = undefined\n      mrtMaterial.uniforms[prop].value = undefined\n      delete mrtMaterial.defines[define]\n      mrtMaterial.needsUpdate = true\n    }\n  }\n\n  setMRTMaterialInScene() {\n    this.visibleMeshes = getVisibleChildren(this._scene)\n\n    for (const c of this.visibleMeshes) {\n      if (c.material) {\n        const originalMaterial = c.material\n        let [cachedOriginalMaterial, mrtMaterial] = this.cachedMaterials.get(c) || []\n\n        if (originalMaterial !== cachedOriginalMaterial) {\n          if (mrtMaterial) mrtMaterial.dispose()\n          mrtMaterial = new MRTMaterial()\n          if (this.USE_MRT) mrtMaterial.defines.USE_MRT = ''\n          mrtMaterial.normalScale = originalMaterial.normalScale\n          mrtMaterial.uniforms.normalScale.value = originalMaterial.normalScale\n          const map =\n            originalMaterial.map ||\n            originalMaterial.normalMap ||\n            originalMaterial.roughnessMap ||\n            originalMaterial.metalnessMap\n          if (map) mrtMaterial.uniforms.uvTransform.value = map.matrix\n          this.cachedMaterials.set(c, [originalMaterial, mrtMaterial])\n        } // update the child's MRT material\n\n        this.keepMaterialMapUpdated(mrtMaterial, originalMaterial, 'normalMap', 'useNormalMap')\n        this.keepMaterialMapUpdated(mrtMaterial, originalMaterial, 'roughnessMap', 'useRoughnessMap')\n        mrtMaterial.uniforms.roughness.value =\n          this.ssrEffect.selection.size === 0 || this.ssrEffect.selection.has(c)\n            ? originalMaterial.roughness || 0\n            : 10e10\n        c.material = mrtMaterial\n      }\n    }\n  }\n\n  unsetMRTMaterialInScene() {\n    for (const c of this.visibleMeshes) {\n      var _c$material\n\n      if (((_c$material = c.material) == null ? void 0 : _c$material.type) === 'MRTMaterial') {\n        c.visible = true // set material back to the original one\n\n        const [originalMaterial] = this.cachedMaterials.get(c)\n        c.material = originalMaterial\n      }\n    }\n  }\n\n  render(renderer, inputBuffer) {\n    this.setMRTMaterialInScene()\n    renderer.setRenderTarget(this.gBuffersRenderTarget)\n    this.renderPass.render(renderer, this.gBuffersRenderTarget)\n    this.unsetMRTMaterialInScene() // render depth and velocity in seperate passes\n\n    if (!this.USE_MRT) this.webgl1DepthPass.renderPass.render(renderer, this.webgl1DepthPass.renderTarget)\n    this.fullscreenMaterial.uniforms.inputTexture.value = inputBuffer.texture\n    this.fullscreenMaterial.uniforms.samples.value = this.ssrEffect.temporalResolvePass.samples\n    this.fullscreenMaterial.uniforms.cameraNear.value = this._camera.near\n    this.fullscreenMaterial.uniforms.cameraFar.value = this._camera.far\n    this.fullscreenMaterial.uniforms.viewMatrix.value.copy(this._camera.matrixWorldInverse)\n    renderer.setRenderTarget(this.renderTarget)\n    renderer.render(this.scene, this.camera)\n  }\n}\n\n/**\n * Options of the SSR effect\n * @typedef {Object} SSROptions\n * @property {Number} [intensity] intensity of the reflections\n * @property {Number} [exponent] exponent by which reflections will be potentiated when composing the current frame's reflections and the accumulated reflections into a final reflection; higher values will make reflections clearer by highlighting darker spots less\n * @property {Number} [distance] maximum distance a reflection ray can travel to find what it reflects\n * @property {Number} [fade] how much reflections will fade out by distance\n * @property {Number} [roughnessFade] how intense reflections should be on rough spots; a higher value will make reflections fade out quicker on rough spots\n * @property {Number} [thickness] maximum depth difference between a ray and the particular depth at its screen position before refining with binary search; higher values will result in better performance\n * @property {Number} [ior] Index of Refraction, used for calculating fresnel; reflections tend to be more intense the steeper the angle between them and the viewer is, the ior parameter sets how much the intensity varies\n * @property {Number} [maxRoughness] maximum roughness a texel can have to have reflections calculated for it\n * @property {Number} [maxDepthDifference] maximum depth difference between a ray and the particular depth at its screen position after refining with binary search; higher values will result in better performance\n * @property {Number} [blend] a value between 0 and 1 to set how much the last frame's reflections should be blended in; higher values will result in less noisy reflections when moving the camera but a more smeary look\n * @property {boolean} [correction] how much pixels should be corrected when doing temporal resolving; higher values will result in less smearing but more noise\n * @property {boolean} [correctionRadius] how many surrounding pixels will be used for neighborhood clamping; a higher value can reduce noise when moving the camera but will result in less performance\n * @property {Number} [blur] how much the blurred reflections should be mixed with the raw reflections\n * @property {Number} [blurKernel] kernel size of the Box Blur Filter; higher kernel sizes will result in blurrier reflections with more artifacts\n * @property {Number} [blurSharpness] exponent of the Box Blur filter; higher values will result in more sharpness\n * @property {Number} [jitter] how intense jittering should be\n * @property {Number} [jitterRoughness] how intense jittering should be in relation to a material's roughness\n * @property {Number} [steps] number of steps a reflection ray can maximally do to find an object it intersected (and thus reflects)\n * @property {Number} [refineSteps] once we had our ray intersect something, we need to find the exact point in space it intersected and thus it reflects; this can be done through binary search with the given number of maximum steps\n * @property {boolean} [missedRays] if there should still be reflections for rays for which a reflecting point couldn't be found; enabling this will result in stretched looking reflections which can look good or bad depending on the angle\n * @property {boolean} [useNormalMap] if roughness maps should be taken account of when calculating reflections\n * @property {boolean} [useRoughnessMap] if normal maps should be taken account of when calculating reflections\n * @property {Number} [resolutionScale] resolution of the SSR effect, a resolution of 0.5 means the effect will be rendered at half resolution\n * @property {Number} [velocityResolutionScale] resolution of the velocity buffer, a resolution of 0.5 means velocity will be rendered at half resolution\n */\n\n/**\n * The options of the SSR effect\n * @type {SSROptions}\n */\nconst defaultSSROptions = {\n  intensity: 1,\n  exponent: 1,\n  distance: 10,\n  fade: 0,\n  roughnessFade: 1,\n  thickness: 10,\n  ior: 1.45,\n  maxRoughness: 1,\n  maxDepthDifference: 10,\n  blend: 0.9,\n  correction: 1,\n  correctionRadius: 1,\n  blur: 0.5,\n  blurKernel: 1,\n  blurSharpness: 10,\n  jitter: 0,\n  jitterRoughness: 0,\n  steps: 20,\n  refineSteps: 5,\n  missedRays: true,\n  useNormalMap: true,\n  useRoughnessMap: true,\n  resolutionScale: 1,\n  velocityResolutionScale: 1,\n}\n\nconst temporalResolve = /* glsl */ `\n  uniform sampler2D inputTexture;\n  uniform sampler2D accumulatedTexture;\n  uniform sampler2D velocityTexture;\n  uniform sampler2D lastVelocityTexture;\n  uniform float blend;\n  uniform float correction;\n  uniform float exponent;\n  uniform float samples;\n  uniform vec2 invTexSize;\n  uniform mat4 curInverseProjectionMatrix;\n  uniform mat4 curCameraMatrixWorld;\n  uniform mat4 prevInverseProjectionMatrix;\n  uniform mat4 prevCameraMatrixWorld;\n  varying vec2 vUv;\n\n  #define MAX_NEIGHBOR_DEPTH_DIFFERENCE 0.001\n  #define FLOAT_EPSILON 0.00001\n  #define FLOAT_ONE_MINUS_EPSILON 0.99999\n\n  vec3 transformexponent;\n  vec3 undoColorTransformExponent;\n\n  vec3 transformColor(vec3 color) {\n    if (exponent == 1.0) return color;\n    return pow(abs(color), transformexponent);\n  }\n\n  vec3 undoColorTransform(vec3 color) {\n    if (exponent == 1.0) return color;\n    return max(pow(abs(color), undoColorTransformExponent), vec3(0.0));\n  }\n\n  void main() {\n    if (exponent != 1.0){\n      transformexponent = vec3(1.0 / exponent);\n      undoColorTransformExponent = vec3(exponent);\n    }\n\n    vec4 inputTexel = textureLod(inputTexture, vUv, 0.0);\n    vec4 accumulatedTexel;\n    vec3 inputColor = transformColor(inputTexel.rgb);\n    vec3 accumulatedColor;\n    float alpha = inputTexel.a;\n    float velocityDisocclusion;\n    bool didReproject = false;\n\n    #ifdef boxBlur\n      vec3 boxBlurredColor = inputTexel.rgb;\n    #endif\n\n    vec4 velocity = textureLod(velocityTexture, vUv, 0.0);\n    bool isMoving = alpha < 1.0 || dot(velocity.xy, velocity.xy) > 0.0;\n    if (isMoving) {\n      vec3 minNeighborColor = inputColor;\n      vec3 maxNeighborColor = inputColor;\n      vec3 col;\n      vec2 neighborUv;\n      vec2 reprojectedUv = vUv-velocity.xy;\n      vec4 lastVelocity = textureLod(lastVelocityTexture, reprojectedUv, 0.0);\n      float depth = velocity.b;\n      float closestDepth = depth;\n      float lastClosestDepth = lastVelocity.b;\n      float neighborDepth;\n      float lastNeighborDepth;\n\n      for (int x = -correctionRadius; x <= correctionRadius; x++) {\n        for (int y = -correctionRadius; y <= correctionRadius; y++) {\n          if (x != 0 || y != 0) {\n            neighborUv = vUv + vec2(x,y) * invTexSize;\n            vec4 neigborVelocity = textureLod(velocityTexture, neighborUv, 0.0);\n            neighborDepth = neigborVelocity.b;\n            col = textureLod(inputTexture, neighborUv, 0.0).xyz;\n            int absX = abs(x);\n            int absY = abs(y);\n\n            #ifdef dilation\n              if (absX == 1 && absY == 1) {\n                if (neighborDepth > closestDepth) {\n                  velocity=neigborVelocity;\n                  closestDepth=neighborDepth;\n                }\n\n                vec4 lastNeighborVelocity = textureLod(velocityTexture, vUv + vec2(x, y) * invTexSize, 0.0);\n                lastNeighborDepth = lastNeighborVelocity.b;\n\n                if (neighborDepth > closestDepth) {\n                  lastVelocity = lastNeighborVelocity;\n                  lastClosestDepth = lastNeighborDepth;\n                }\n              }\n            #endif\n\n            if (abs(depth-neighborDepth) < MAX_NEIGHBOR_DEPTH_DIFFERENCE) {\n              #ifdef boxBlur\n                if (absX <= 2 && absY <= 2) boxBlurredColor += col;\n              #endif\n\n              col = transformColor(col);\n              minNeighborColor = min(col, minNeighborColor);\n              maxNeighborColor = max(col, maxNeighborColor);\n            }\n          }\n        }\n      }\n\n      float velocityLength = length(lastVelocity.xy - velocity.xy);\n      velocityDisocclusion = (velocityLength - 0.000005) * 10.0;\n      velocityDisocclusion *= velocityDisocclusion;\n      reprojectedUv = vUv - velocity.xy;\n\n      #ifdef boxBlur\n        float pxRadius = correctionRadius > 5 ? 121.0 : pow(float(correctionRadius * 2 + 1), 2.0);\n        boxBlurredColor /= pxRadius;\n        boxBlurredColor = transformColor(boxBlurredColor);\n      #endif\n\n      if (\n        reprojectedUv.x >=0.0 &&\n        reprojectedUv.x <= 1.0 &&\n        reprojectedUv.y >= 0.0 &&\n        reprojectedUv.y <= 1.0\n      ) {\n        accumulatedTexel = textureLod(accumulatedTexture, reprojectedUv, 0.0);\n        accumulatedColor = transformColor(accumulatedTexel.rgb);\n        vec3 clampedColor = clamp(accumulatedColor, minNeighborColor, maxNeighborColor);\n        accumulatedColor = mix(accumulatedColor, clampedColor, correction);\n        didReproject = true;\n      } else {\n        #ifdef boxBlur\n          accumulatedColor=boxBlurredColor;\n        #else\n          accumulatedColor=inputColor;\n        #endif\n      }\n\n      if (velocity.r > FLOAT_ONE_MINUS_EPSILON && velocity.g > FLOAT_ONE_MINUS_EPSILON) {\n        alpha = 0.0;\n        velocityDisocclusion = 1.0;\n      }\n    } else {\n      accumulatedColor = transformColor(textureLod(accumulatedTexture, vUv, 0.0).rgb);\n    }\n\n    vec3 outputColor = inputColor;\n\n    #include <custom_compose_shader>\n\n    gl_FragColor = vec4(undoColorTransform(outputColor), alpha);\n  }\n`\n\nclass TemporalResolveMaterial extends ShaderMaterial {\n  constructor(customComposeShader) {\n    const fragmentShader = temporalResolve.replace('#include <custom_compose_shader>', customComposeShader)\n    super({\n      type: 'TemporalResolveMaterial',\n      uniforms: {\n        inputTexture: new Uniform(null),\n        accumulatedTexture: new Uniform(null),\n        velocityTexture: new Uniform(null),\n        lastVelocityTexture: new Uniform(null),\n        samples: new Uniform(1),\n        blend: new Uniform(0.5),\n        correction: new Uniform(1),\n        exponent: new Uniform(1),\n        invTexSize: new Uniform(new Vector2()),\n      },\n      defines: {\n        correctionRadius: 1,\n      },\n      vertexShader,\n      fragmentShader,\n    })\n  }\n}\n\n// this shader is from: https://github.com/gkjohnson/threejs-sandbox\n// a second set of bone information from the previou frame\n\nconst prev_skinning_pars_vertex =\n  /* glsl */\n  `\n    #ifdef USE_SKINNING\n      #ifdef BONE_TEXTURE\n        uniform sampler2D prevBoneTexture;\n        mat4 getPrevBoneMatrix( const in float i ) {\n          float j = i * 4.0;\n          float x = mod( j, float( boneTextureSize ) );\n          float y = floor( j / float( boneTextureSize ) );\n          float dx = 1.0 / float( boneTextureSize );\n          float dy = 1.0 / float( boneTextureSize );\n          y = dy * ( y + 0.5 );\n          vec4 v1 = texture2D( prevBoneTexture, vec2( dx * ( x + 0.5 ), y ) );\n          vec4 v2 = texture2D( prevBoneTexture, vec2( dx * ( x + 1.5 ), y ) );\n          vec4 v3 = texture2D( prevBoneTexture, vec2( dx * ( x + 2.5 ), y ) );\n          vec4 v4 = texture2D( prevBoneTexture, vec2( dx * ( x + 3.5 ), y ) );\n          mat4 bone = mat4( v1, v2, v3, v4 );\n          return bone;\n        }\n      #else\n        uniform mat4 prevBoneMatrices[ MAX_BONES ];\n        mat4 getPrevBoneMatrix( const in float i ) {\n          mat4 bone = prevBoneMatrices[ int(i) ];\n          return bone;\n        }\n      #endif\n    #endif\n` // Returns the body of the vertex shader for the velocity buffer and\n// outputs the position of the current and last frame positions\n\nconst velocity_vertex =\n  /* glsl */\n  `\n    vec3 transformed;\n\n    // Get the normal\n    ${ShaderChunk.skinbase_vertex}\n    ${ShaderChunk.beginnormal_vertex}\n    ${ShaderChunk.skinnormal_vertex}\n    ${ShaderChunk.defaultnormal_vertex}\n\n    // Get the current vertex position\n    transformed = vec3( position );\n    ${ShaderChunk.skinning_vertex}\n    newPosition = velocityMatrix * vec4( transformed, 1.0 );\n\n    // Get the previous vertex position\n    transformed = vec3( position );\n    ${ShaderChunk.skinbase_vertex.replace(/mat4 /g, '').replace(/getBoneMatrix/g, 'getPrevBoneMatrix')}\n    ${ShaderChunk.skinning_vertex.replace(/vec4 /g, '')}\n    prevPosition = prevVelocityMatrix * vec4( transformed, 1.0 );\n\n    gl_Position = newPosition;\n`\nclass VelocityMaterial extends ShaderMaterial {\n  constructor() {\n    super({\n      uniforms: {\n        prevVelocityMatrix: {\n          value: new Matrix4(),\n        },\n        velocityMatrix: {\n          value: new Matrix4(),\n        },\n        prevBoneTexture: {\n          value: null,\n        },\n        interpolateGeometry: {\n          value: 0,\n        },\n        intensity: {\n          value: 1,\n        },\n        boneTexture: {\n          value: null,\n        },\n        alphaTest: {\n          value: 0.0,\n        },\n        map: {\n          value: null,\n        },\n        alphaMap: {\n          value: null,\n        },\n        opacity: {\n          value: 1.0,\n        },\n      },\n      vertexShader:\n        /* glsl */\n        `\n                    #define MAX_BONES 1024\n\n                    ${ShaderChunk.skinning_pars_vertex}\n                    ${prev_skinning_pars_vertex}\n\n                    uniform mat4 velocityMatrix;\n                    uniform mat4 prevVelocityMatrix;\n                    uniform float interpolateGeometry;\n                    varying vec4 prevPosition;\n                    varying vec4 newPosition;\n          varying vec2 vHighPrecisionZW;\n\n                    void main() {\n\n                        ${velocity_vertex}\n\n            vHighPrecisionZW = gl_Position.zw;\n\n                    }`,\n      fragmentShader:\n        /* glsl */\n        `\n                    uniform float intensity;\n                    varying vec4 prevPosition;\n                    varying vec4 newPosition;\n          varying vec2 vHighPrecisionZW;\n\n                    void main() {\n            #ifdef FULL_MOVEMENT\n            gl_FragColor = vec4( 1., 1., 1. - gl_FragCoord.z, 0. );\n            return;\n            #endif\n\n                        vec2 pos0 = (prevPosition.xy / prevPosition.w) * 0.5 + 0.5;\n                        vec2 pos1 = (newPosition.xy / newPosition.w) * 0.5 + 0.5;\n\n                        vec2 vel = pos1 - pos0;\n\n            float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n                        gl_FragColor = vec4( vel, 1. - fragCoordZ, 0. );\n\n                    }`,\n    })\n    this.isVelocityMaterial = true\n  }\n}\n\nconst backgroundColor = new Color(0)\nconst updateProperties = ['visible', 'wireframe', 'side']\nclass VelocityPass extends Pass {\n  constructor(scene, camera) {\n    var _window, _window2\n\n    super('VelocityPass')\n    this.cachedMaterials = new WeakMap()\n    this.lastCameraTransform = {\n      position: new Vector3(),\n      quaternion: new Quaternion(),\n    }\n    this.visibleMeshes = []\n    this.renderedMeshesThisFrame = 0\n    this.renderedMeshesLastFrame = 0\n    this._scene = scene\n    this._camera = camera\n    this.renderTarget = new WebGLRenderTarget(\n      ((_window = window) == null ? void 0 : _window.innerWidth) || 1000,\n      ((_window2 = window) == null ? void 0 : _window2.innerHeight) || 1000,\n      {\n        type: HalfFloatType,\n      }\n    )\n  }\n\n  setVelocityMaterialInScene() {\n    this.renderedMeshesThisFrame = 0\n    this.visibleMeshes = getVisibleChildren(this._scene)\n\n    for (const c of this.visibleMeshes) {\n      var _c$skeleton2\n\n      const originalMaterial = c.material\n      let [cachedOriginalMaterial, velocityMaterial] = this.cachedMaterials.get(c) || []\n\n      if (originalMaterial !== cachedOriginalMaterial) {\n        var _c$skeleton\n\n        velocityMaterial = new VelocityMaterial()\n        velocityMaterial.lastMatrixWorld = new Matrix4()\n        c.material = velocityMaterial\n        if ((_c$skeleton = c.skeleton) != null && _c$skeleton.boneTexture) this.saveBoneTexture(c)\n        this.cachedMaterials.set(c, [originalMaterial, velocityMaterial])\n      }\n\n      velocityMaterial.uniforms.velocityMatrix.value.multiplyMatrices(this._camera.projectionMatrix, c.modelViewMatrix)\n\n      if (c.userData.needsUpdatedReflections || originalMaterial.map instanceof VideoTexture) {\n        if (!('FULL_MOVEMENT' in velocityMaterial.defines)) velocityMaterial.needsUpdate = true\n        velocityMaterial.defines.FULL_MOVEMENT = ''\n      } else {\n        if ('FULL_MOVEMENT' in velocityMaterial.defines) {\n          delete velocityMaterial.defines.FULL_MOVEMENT\n          velocityMaterial.needsUpdate = true\n        }\n      }\n\n      c.visible =\n        this.cameraMovedThisFrame ||\n        !c.matrixWorld.equals(velocityMaterial.lastMatrixWorld) ||\n        c.skeleton ||\n        'FULL_MOVEMENT' in velocityMaterial.defines\n      c.material = velocityMaterial\n      if (!c.visible) continue\n      this.renderedMeshesThisFrame++\n\n      for (const prop of updateProperties) velocityMaterial[prop] = originalMaterial[prop]\n\n      if ((_c$skeleton2 = c.skeleton) != null && _c$skeleton2.boneTexture) {\n        velocityMaterial.defines.USE_SKINNING = ''\n        velocityMaterial.defines.BONE_TEXTURE = ''\n        velocityMaterial.uniforms.boneTexture.value = c.skeleton.boneTexture\n      }\n    }\n  }\n\n  saveBoneTexture(object) {\n    let boneTexture = object.material.uniforms.prevBoneTexture.value\n\n    if (boneTexture && boneTexture.image.width === object.skeleton.boneTexture.width) {\n      boneTexture = object.material.uniforms.prevBoneTexture.value\n      boneTexture.image.data.set(object.skeleton.boneTexture.image.data)\n    } else {\n      var _boneTexture\n      ;(_boneTexture = boneTexture) == null ? void 0 : _boneTexture.dispose()\n      const boneMatrices = object.skeleton.boneTexture.image.data.slice()\n      const size = object.skeleton.boneTexture.image.width\n      boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType)\n      object.material.uniforms.prevBoneTexture.value = boneTexture\n      boneTexture.needsUpdate = true\n    }\n  }\n\n  unsetVelocityMaterialInScene() {\n    for (const c of this.visibleMeshes) {\n      if (c.material.isVelocityMaterial) {\n        var _c$skeleton3\n\n        c.visible = true\n        c.material.lastMatrixWorld.copy(c.matrixWorld)\n        c.material.uniforms.prevVelocityMatrix.value.multiplyMatrices(this._camera.projectionMatrix, c.modelViewMatrix)\n        if ((_c$skeleton3 = c.skeleton) != null && _c$skeleton3.boneTexture) this.saveBoneTexture(c)\n        c.material = this.cachedMaterials.get(c)[0]\n      }\n    }\n  }\n\n  setSize(width, height) {\n    this.renderTarget.setSize(width, height)\n  }\n\n  renderVelocity(renderer) {\n    renderer.setRenderTarget(this.renderTarget)\n\n    if (this.renderedMeshesThisFrame > 0) {\n      const { background } = this._scene\n      this._scene.background = backgroundColor\n      renderer.render(this._scene, this._camera)\n      this._scene.background = background\n    } else {\n      renderer.clearColor()\n    }\n  }\n\n  checkCameraMoved() {\n    const moveDist = this.lastCameraTransform.position.distanceToSquared(this._camera.position)\n    const rotateDist = 8 * (1 - this.lastCameraTransform.quaternion.dot(this._camera.quaternion))\n\n    if (moveDist > 0.000001 || rotateDist > 0.000001) {\n      this.lastCameraTransform.position.copy(this._camera.position)\n      this.lastCameraTransform.quaternion.copy(this._camera.quaternion)\n      return true\n    }\n\n    return false\n  }\n\n  render(renderer) {\n    this.cameraMovedThisFrame = this.checkCameraMoved()\n    this.setVelocityMaterialInScene()\n    if (this.renderedMeshesThisFrame > 0 || this.renderedMeshesLastFrame > 0) this.renderVelocity(renderer)\n    this.unsetVelocityMaterialInScene()\n    this.renderedMeshesLastFrame = this.renderedMeshesThisFrame\n  }\n}\n\nconst zeroVec2 = new Vector2() // the following variables can be accessed by the custom compose shader:\n// \"inputTexel\", \"accumulatedTexel\", \"inputColor\", \"accumulatedColor\", \"alpha\", \"velocityDisocclusion\", \"didReproject\", \"boxBlurredColor\" (if using box blur)\n// the custom compose shader will write the final color to the variable \"outputColor\"\n\nclass TemporalResolvePass extends Pass {\n  constructor(scene, camera, customComposeShader, options = {}) {\n    super('TemporalResolvePass')\n    this.velocityPass = null\n    this.velocityResolutionScale = 1\n    this.samples = 1\n    this.lastCameraTransform = {\n      position: new Vector3(),\n      quaternion: new Quaternion(),\n    }\n    this._scene = scene\n    this._camera = camera\n    this.renderTarget = new WebGLRenderTarget(1, 1, {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      type: HalfFloatType,\n      depthBuffer: false,\n    })\n    this.velocityPass = new VelocityPass(scene, camera)\n    this.fullscreenMaterial = new TemporalResolveMaterial(customComposeShader)\n    this.fullscreenMaterial.defines.correctionRadius = options.correctionRadius || 1\n    if (options.dilation) this.fullscreenMaterial.defines.dilation = ''\n    if (options.boxBlur) this.fullscreenMaterial.defines.boxBlur = ''\n    this.setupFramebuffers(1, 1)\n    this.checkCanUseSharedVelocityTexture()\n  }\n\n  dispose() {\n    if (this._scene.userData.velocityTexture === this.velocityPass.renderTarget.texture) {\n      delete this._scene.userData.velocityTexture\n      delete this._scene.userData.lastVelocityTexture\n    }\n\n    this.renderTarget.dispose()\n    this.accumulatedTexture.dispose()\n    this.fullscreenMaterial.dispose()\n    this.velocityPass.dispose()\n  }\n\n  setSize(width, height) {\n    this.renderTarget.setSize(width, height)\n    this.velocityPass.setSize(width * this.velocityResolutionScale, height * this.velocityResolutionScale)\n    this.velocityPass.renderTarget.texture.minFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter\n    this.velocityPass.renderTarget.texture.magFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter\n    this.velocityPass.renderTarget.texture.needsUpdate = true\n    this.fullscreenMaterial.uniforms.invTexSize.value.set(1 / width, 1 / height)\n    this.setupFramebuffers(width, height)\n  }\n\n  setupFramebuffers(width, height) {\n    if (this.accumulatedTexture) this.accumulatedTexture.dispose()\n    if (this.lastVelocityTexture) this.lastVelocityTexture.dispose()\n    this.accumulatedTexture = new FramebufferTexture(width, height, RGBAFormat)\n    this.accumulatedTexture.minFilter = LinearFilter\n    this.accumulatedTexture.magFilter = LinearFilter\n    this.accumulatedTexture.type = HalfFloatType\n    this.lastVelocityTexture = new FramebufferTexture(\n      width * this.velocityResolutionScale,\n      height * this.velocityResolutionScale,\n      RGBAFormat\n    )\n    this.lastVelocityTexture.minFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter\n    this.lastVelocityTexture.magFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter\n    this.lastVelocityTexture.type = HalfFloatType\n    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.accumulatedTexture\n    this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this.lastVelocityTexture\n    this.fullscreenMaterial.needsUpdate = true\n  }\n\n  checkCanUseSharedVelocityTexture() {\n    const canUseSharedVelocityTexture =\n      this._scene.userData.velocityTexture &&\n      this.velocityPass.renderTarget.texture !== this._scene.userData.velocityTexture\n\n    if (canUseSharedVelocityTexture) {\n      // let's use the shared one instead\n      if (this.velocityPass.renderTarget.texture === this.fullscreenMaterial.uniforms.velocityTexture.value) {\n        this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this._scene.userData.lastVelocityTexture\n        this.fullscreenMaterial.uniforms.velocityTexture.value = this._scene.userData.velocityTexture\n        this.fullscreenMaterial.needsUpdate = true\n      }\n    } else {\n      // let's stop using the shared one (if used) and mark ours as the shared one instead\n      if (this.velocityPass.renderTarget.texture !== this.fullscreenMaterial.uniforms.velocityTexture.value) {\n        this.fullscreenMaterial.uniforms.velocityTexture.value = this.velocityPass.renderTarget.texture\n        this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this.lastVelocityTexture\n        this.fullscreenMaterial.needsUpdate = true\n\n        if (!this._scene.userData.velocityTexture) {\n          this._scene.userData.velocityTexture = this.velocityPass.renderTarget.texture\n          this._scene.userData.lastVelocityTexture = this.lastVelocityTexture\n        }\n      }\n    }\n\n    return this.velocityPass.renderTarget.texture !== this.fullscreenMaterial.uniforms.velocityTexture.value\n  }\n\n  checkNeedsResample() {\n    const moveDist = this.lastCameraTransform.position.distanceToSquared(this._camera.position)\n    const rotateDist = 8 * (1 - this.lastCameraTransform.quaternion.dot(this._camera.quaternion))\n\n    if (moveDist > 0.000001 || rotateDist > 0.000001) {\n      this.samples = 1\n      this.lastCameraTransform.position.copy(this._camera.position)\n      this.lastCameraTransform.quaternion.copy(this._camera.quaternion)\n    }\n  }\n\n  render(renderer) {\n    this.samples++\n    this.checkNeedsResample()\n    this.fullscreenMaterial.uniforms.samples.value = this.samples // const isUsingSharedVelocityTexture = this.checkCanUseSharedVelocityTexture()\n    // if (!isUsingSharedVelocityTexture) this.velocityPass.render(renderer)\n\n    renderer.setRenderTarget(this.renderTarget)\n    renderer.render(this.scene, this.camera) // save the render target's texture for use in next frame\n\n    renderer.copyFramebufferToTexture(zeroVec2, this.accumulatedTexture)\n    renderer.setRenderTarget(this.velocityPass.renderTarget)\n    renderer.copyFramebufferToTexture(zeroVec2, this.lastVelocityTexture)\n  }\n}\n\n// source: https://observablehq.com/@jrus/halton\nconst halton = function halton(index, base) {\n  let fraction = 1\n  let result = 0\n\n  while (index > 0) {\n    fraction /= base\n    result += fraction * (index % base)\n    index = ~~(index / base) // floor division\n  }\n\n  return result\n} // generates Halton tuples in the range [-0.5:0.5]\n\nconst generateHalton23Points = (count) => {\n  const data = []\n  let i = 1\n  const end = i + count\n\n  for (; i < end; i++) {\n    data.push([halton(i, 2) - 0.5, halton(i, 3) - 0.5])\n  }\n\n  return data\n}\n\n/* eslint-disable camelcase */\n\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') // $& means the whole matched string\n} // credits for the box-projecting shader code go to codercat (https://codercat.tk)\n\nconst worldposReplace =\n  /* glsl */\n  `\n#if defined( USE_ENVMAP ) || defined(  ) || defined ( USE_SHADOWMAP )\n    vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n    #ifdef BOX_PROJECTED_ENV_MAP\n        vWorldPosition = worldPosition.xyz;\n    #endif\n#endif\n`\nconst boxProjectDefinitions =\n  /* glsl */\n  `\n#ifdef BOX_PROJECTED_ENV_MAP\n    uniform vec3 envMapSize;\n    uniform vec3 envMapPosition;\n    varying vec3 vWorldPosition;\n\n    vec3 parallaxCorrectNormal( vec3 v, vec3 cubeSize, vec3 cubePos ) {\n        vec3 nDir = normalize( v );\n\n        vec3 rbmax = ( .5 * cubeSize + cubePos - vWorldPosition ) / nDir;\n        vec3 rbmin = ( -.5 * cubeSize + cubePos - vWorldPosition ) / nDir;\n\n        vec3 rbminmax;\n\n        rbminmax.x = ( nDir.x > 0. ) ? rbmax.x : rbmin.x;\n        rbminmax.y = ( nDir.y > 0. ) ? rbmax.y : rbmin.y;\n        rbminmax.z = ( nDir.z > 0. ) ? rbmax.z : rbmin.z;\n\n        float correction = min( min( rbminmax.x, rbminmax.y ), rbminmax.z );\n        vec3 boxIntersection = vWorldPosition + nDir * correction;\n\n        return boxIntersection - cubePos;\n    }\n#endif\n` // will be inserted after \"vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\"\n\nconst getIBLIrradiance_patch =\n  /* glsl */\n  `\n#ifdef BOX_PROJECTED_ENV_MAP\n    worldNormal = parallaxCorrectNormal( worldNormal, envMapSize, envMapPosition );\n#endif\n` // will be inserted after \"reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\"\n\nconst getIBLRadiance_patch =\n  /* glsl */\n  `\n#ifdef BOX_PROJECTED_ENV_MAP\n    reflectVec = parallaxCorrectNormal( reflectVec, envMapSize, envMapPosition );\n#endif\n`\nfunction useBoxProjectedEnvMap(shader, envMapPosition, envMapSize) {\n  // defines\n  shader.defines.BOX_PROJECTED_ENV_MAP = '' // uniforms\n\n  shader.uniforms.envMapPosition = {\n    value: envMapPosition,\n  }\n  shader.uniforms.envMapSize = {\n    value: envMapSize,\n  }\n  const line1 = new RegExp(\n    escapeRegExp('vec3 worldNormal = inverseTransformDirection ( normal , viewMatrix ) ;').replaceAll(' ', '\\\\s*'),\n    'g'\n  )\n  const line2 = new RegExp(\n    escapeRegExp('reflectVec = inverseTransformDirection ( reflectVec , viewMatrix ) ;').replaceAll(' ', '\\\\s*'),\n    'g'\n  ) // vertex shader\n\n  shader.vertexShader =\n    'varying vec3 vWorldPosition;\\n' + shader.vertexShader.replace('#include <worldpos_vertex>', worldposReplace) // fragment shader\n\n  shader.fragmentShader =\n    boxProjectDefinitions +\n    '\\n' +\n    shader.fragmentShader\n      .replace('#include <envmap_physical_pars_fragment>', ShaderChunk.envmap_physical_pars_fragment)\n      .replace(\n        line1,\n        `vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n                ${getIBLIrradiance_patch}`\n      )\n      .replace(\n        line2,\n        `reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n                ${getIBLRadiance_patch}`\n      )\n}\n\nconst noResetSamplesProperties = ['blur', 'blurSharpness', 'blurKernel']\nconst defaultCubeRenderTarget = new WebGLCubeRenderTarget(1)\nlet pmremGenerator\nclass SSREffect extends Effect {\n  /**\n   * @param {THREE.Scene} scene The scene of the SSR effect\n   * @param {THREE.Camera} camera The camera with which SSR is being rendered\n   * @param {SSROptions} [options] The optional options for the SSR effect\n   */\n  constructor(scene, camera, options = defaultSSROptions) {\n    super('SSREffect', finalSSRShader, {\n      type: 'FinalSSRMaterial',\n      uniforms: new Map([\n        ['reflectionsTexture', new Uniform(null)],\n        ['blur', new Uniform(0)],\n        ['blurSharpness', new Uniform(0)],\n        ['blurKernel', new Uniform(0)],\n      ]),\n      defines: new Map([['RENDER_MODE', '0']]),\n    })\n    this.haltonSequence = generateHalton23Points(1024)\n    this.haltonIndex = 0\n    this.selection = new Selection()\n    this.lastSize = void 0\n    this.cubeCamera = new CubeCamera(0.001, 1000, defaultCubeRenderTarget)\n    this.usingBoxProjectedEnvMap = false\n    this._scene = scene\n    this._camera = camera\n    const trOptions = {\n      boxBlur: true,\n      dilation: true,\n    }\n    options = { ...defaultSSROptions, ...options, ...trOptions } // set up passes\n    // temporal resolve pass\n\n    this.temporalResolvePass = new TemporalResolvePass(scene, camera, trCompose, options)\n    this.uniforms.get('reflectionsTexture').value = this.temporalResolvePass.renderTarget.texture // reflections pass\n\n    this.reflectionsPass = new ReflectionsPass(this, options)\n    this.temporalResolvePass.fullscreenMaterial.uniforms.inputTexture.value = this.reflectionsPass.renderTarget.texture\n    this.lastSize = {\n      width: options.width,\n      height: options.height,\n      resolutionScale: options.resolutionScale,\n      velocityResolutionScale: options.velocityResolutionScale,\n    }\n    this.setSize(options.width, options.height)\n    this.makeOptionsReactive(options)\n  }\n\n  makeOptionsReactive(options) {\n    let needsUpdate = false\n    const reflectionPassFullscreenMaterialUniforms = this.reflectionsPass.fullscreenMaterial.uniforms\n    const reflectionPassFullscreenMaterialUniformsKeys = Object.keys(reflectionPassFullscreenMaterialUniforms)\n\n    for (const key of Object.keys(options)) {\n      Object.defineProperty(this, key, {\n        get() {\n          return options[key]\n        },\n\n        set(value) {\n          if (options[key] === value && needsUpdate) return\n          options[key] = value\n\n          if (!noResetSamplesProperties.includes(key)) {\n            this.setSize(this.lastSize.width, this.lastSize.height, true)\n          }\n\n          switch (key) {\n            case 'resolutionScale':\n              this.setSize(this.lastSize.width, this.lastSize.height)\n              break\n\n            case 'velocityResolutionScale':\n              this.temporalResolvePass.velocityResolutionScale = value\n              this.setSize(this.lastSize.width, this.lastSize.height, true)\n              break\n\n            case 'blur':\n              this.uniforms.get('blur').value = value\n              break\n\n            case 'blurSharpness':\n              this.uniforms.get('blurSharpness').value = value\n              break\n\n            case 'blurKernel':\n              this.uniforms.get('blurKernel').value = value\n              break\n            // defines\n\n            case 'steps':\n              this.reflectionsPass.fullscreenMaterial.defines.steps = parseInt(value)\n              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate\n              break\n\n            case 'refineSteps':\n              this.reflectionsPass.fullscreenMaterial.defines.refineSteps = parseInt(value)\n              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate\n              break\n\n            case 'missedRays':\n              if (value) {\n                this.reflectionsPass.fullscreenMaterial.defines.missedRays = ''\n              } else {\n                delete this.reflectionsPass.fullscreenMaterial.defines.missedRays\n              }\n\n              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate\n              break\n\n            case 'correctionRadius':\n              this.temporalResolvePass.fullscreenMaterial.defines.correctionRadius = Math.round(value)\n              this.temporalResolvePass.fullscreenMaterial.needsUpdate = needsUpdate\n              break\n\n            case 'blend':\n              this.temporalResolvePass.fullscreenMaterial.uniforms.blend.value = value\n              break\n\n            case 'correction':\n              this.temporalResolvePass.fullscreenMaterial.uniforms.correction.value = value\n              break\n\n            case 'exponent':\n              this.temporalResolvePass.fullscreenMaterial.uniforms.exponent.value = value\n              break\n\n            case 'distance':\n              reflectionPassFullscreenMaterialUniforms.rayDistance.value = value\n            // must be a uniform\n\n            default:\n              if (reflectionPassFullscreenMaterialUniformsKeys.includes(key)) {\n                reflectionPassFullscreenMaterialUniforms[key].value = value\n              }\n          }\n        },\n      }) // apply all uniforms and defines\n\n      this[key] = options[key]\n    }\n\n    needsUpdate = true\n  }\n\n  setSize(width, height, force = false) {\n    if (\n      !force &&\n      width === this.lastSize.width &&\n      height === this.lastSize.height &&\n      this.resolutionScale === this.lastSize.resolutionScale &&\n      this.velocityResolutionScale === this.lastSize.velocityResolutionScale\n    )\n      return\n    this.temporalResolvePass.setSize(width, height)\n    this.reflectionsPass.setSize(width, height)\n    this.lastSize = {\n      width,\n      height,\n      resolutionScale: this.resolutionScale,\n      velocityResolutionScale: this.velocityResolutionScale,\n    }\n  }\n\n  generateBoxProjectedEnvMapFallback(renderer, position = new Vector3(), size = new Vector3(), envMapSize = 512) {\n    this.cubeCamera.renderTarget.dispose()\n    this.cubeCamera.renderTarget = new WebGLCubeRenderTarget(envMapSize)\n    this.cubeCamera.position.copy(position)\n    this.cubeCamera.updateMatrixWorld()\n    this.cubeCamera.update(renderer, this._scene)\n\n    if (!pmremGenerator) {\n      pmremGenerator = new PMREMGenerator(renderer)\n      pmremGenerator.compileCubemapShader()\n    }\n\n    const envMap = pmremGenerator.fromCubemap(this.cubeCamera.renderTarget.texture).texture\n    envMap.minFilter = LinearFilter\n    envMap.magFilter = LinearFilter\n    const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useBoxProjectedEnvMap(reflectionsMaterial, position, size)\n    reflectionsMaterial.fragmentShader = reflectionsMaterial.fragmentShader\n      .replace('vec3 worldPos', 'worldPos')\n      .replace('varying vec3 vWorldPosition;', 'vec3 worldPos;')\n    reflectionsMaterial.uniforms.envMapPosition.value.copy(position)\n    reflectionsMaterial.uniforms.envMapSize.value.copy(size)\n    setupEnvMap(reflectionsMaterial, envMap, envMapSize)\n    this.usingBoxProjectedEnvMap = true\n    return envMap\n  }\n\n  setIBLRadiance(iblRadiance, renderer) {\n    this._scene.traverse((c) => {\n      if (c.material) {\n        var _renderer$properties$\n\n        const uniforms =\n          (_renderer$properties$ = renderer.properties.get(c.material)) == null\n            ? void 0\n            : _renderer$properties$.uniforms\n\n        if (uniforms && 'disableIBLRadiance' in uniforms) {\n          uniforms.disableIBLRadiance.value = iblRadiance\n        }\n      }\n    })\n  }\n\n  deleteBoxProjectedEnvMapFallback() {\n    const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial\n    reflectionsMaterial.uniforms.envMap.value = null\n    reflectionsMaterial.fragmentShader = reflectionsMaterial.fragmentShader.replace('worldPos = ', 'vec3 worldPos = ')\n    delete reflectionsMaterial.defines.BOX_PROJECTED_ENV_MAP\n    reflectionsMaterial.needsUpdate = true\n    this.usingBoxProjectedEnvMap = false\n  }\n\n  dispose() {\n    super.dispose()\n    this.reflectionsPass.dispose()\n    this.temporalResolvePass.dispose()\n  }\n\n  update(renderer, inputBuffer) {\n    if (!this.usingBoxProjectedEnvMap && this._scene.environment) {\n      const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial\n      let envMap = null // not sure if there is a cleaner way to find the internal texture of a CubeTexture (when used as scene environment)\n\n      this._scene.traverse((c) => {\n        if (!envMap && c.material && !c.material.envMap) {\n          const properties = renderer.properties.get(c.material)\n          if ('envMap' in properties && properties.envMap instanceof Texture) envMap = properties.envMap\n        }\n      })\n\n      if (envMap) {\n        const envMapCubeUVHeight = this._scene.environment.image.height\n        setupEnvMap(reflectionsMaterial, envMap, envMapCubeUVHeight)\n      }\n    }\n\n    this.haltonIndex = (this.haltonIndex + 1) % this.haltonSequence.length\n    const [x, y] = this.haltonSequence[this.haltonIndex]\n    const { width, height } = this.lastSize\n    this.temporalResolvePass.velocityPass.render(renderer) // jittering the view offset each frame reduces aliasing for the reflection\n\n    if (this._camera.setViewOffset) this._camera.setViewOffset(width, height, x, y, width, height) // render reflections of current frame\n\n    this.reflectionsPass.render(renderer, inputBuffer) // compose reflection of last and current frame into one reflection\n\n    this.temporalResolvePass.render(renderer)\n\n    this._camera.clearViewOffset()\n  }\n\n  static patchDirectEnvIntensity(envMapIntensity = 0) {\n    if (envMapIntensity === 0) {\n      ShaderChunk.envmap_physical_pars_fragment = ShaderChunk.envmap_physical_pars_fragment.replace(\n        'vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {',\n        'vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) { return vec3(0.0);'\n      )\n    } else {\n      ShaderChunk.envmap_physical_pars_fragment = ShaderChunk.envmap_physical_pars_fragment.replace(\n        'vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );',\n        'vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness ) * ' + envMapIntensity.toFixed(5) + ';'\n      )\n    }\n  }\n}\n\nexport { SSREffect, defaultSSROptions }\n"],"names":["fragmentShader","halton"],"mappings":"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"}